<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AVL Tree Visualizer</title>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        #svgWrap{
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #mainSvg {
            width: 90vw;
            height: 80vh;
            overflow: visible;
        }
    </style>
</head>

<body>
    <h1>AVL Tree Visualizer</h1>
    <div>
        <input type="text" id="insert"/>
        <button id="insertButton">
            Insert
        </button>

        <input type="text" id="delete"/>
        <button id="deleteButton">
            Delete
        </button>

        <input type="text" id="find"/>
        <button id="findButton">
            Find
        </button>

        <button id="clearButton">
            Clear
        </button>

        <button id="randomButton">
            Random Tree
        </button>
    </div>
    <div id="svgWrap">
        <svg id="mainSvg" width="600px" height="400px">

        </svg>
    </div>
    

    <script>
        //https://stackoverflow.com/questions/3642035/jquerys-append-not-working-with-svg-element <-- Source for svg making stuff
        function addShape(tag, attrs){
            var el= document.createElementNS('http://www.w3.org/2000/svg', tag);
            for (var k in attrs)
                el.setAttribute(k, attrs[k]);
            document.getElementById('mainSvg').appendChild(el);
        }

        function addText(text, attrs){
            var el= document.createElementNS('http://www.w3.org/2000/svg', "text");
            for (var k in attrs)
                el.setAttribute(k, attrs[k]);
            
            el.textContent = text;

            document.getElementById('mainSvg').appendChild(el);
        }

        const nodeRadius = 40;
        var root = null;
        const nodes = [];

        function addNode(value, x, y){
            addShape("circle", {cx:x, cy:y, r:nodeRadius, stroke:"black", "stroke-width":5, fill:"white", id:"myCircle"});
            addText(value, {x:x, y:y, "text-anchor":"middle", "dominant-baseline":"middle", "font-family":"monospace", "font-size":"24", "fill":"black"})
        }

        $(document).ready(function() {
            $("#insertButton").click(function() {
                var w = $("#mainSvg").width();
                var h = $("#mainSvg").height();
                //addNode(5, w/2, 0);

                var value = $("#insert").val();
                value = parseInt(value, 10);
                const n = new Node(value, null);
                if(root == null){
                    console.log("Adding new node at the root: " + n.value);
                    root = n;
                    root.display();
                }else{
                    root.insert(n);
                }
                $("#insert").val('');
            });

            $("#deleteButton").click(function(){
                var value = $("#delete").val();
                value = parseInt(value, 10);
                if(root != null){
                    root.delete(value,[]);
                }
                $("#delete").val('');
            });

            $("#findButton").click(function(){
                alert("Find clicked!");
            });

            $("#clearButton").click(function(){
                alert("Clear clicked!");
            });

            $("#randomButton").click(function(){
                
                //temporary, displays all the nodes
                if(root != null)
                    root.display();
            });
        });

        class Node {
            constructor(value, parent){
                this.value = value;
                this.left = null;
                this.right = null;
                this.parent = parent;
            }

            getValue(){
                return this.value;
            }

            getHeight(){
                var l = -1;
                var r = -1;
                if(this.left != null)
                    l = this.left.getHeight();
                if(this.right != null)
                    r = this.right.getHeight();
                if(l > r){
                    return l + 1;
                }else{
                    return r + 1;
                }
            }

            getBalance(){
                var l = -1;
                var r = -1;
                if(this.left != null)
                    l = this.left.getHeight();
                if(this.right != null)
                    r = this.right.getHeight();

                return r - l; //positive = right tree heavy, negative = left tree heavy, 0 = balanced
            }

            validateTree(){
                console.log("Node of value " + this.value + " is validating...")
                var l = -1;
                var r = -1;
                if(this.left != null)
                    l = this.left.getHeight();
                if(this.right != null)
                    r = this.right.getHeight();

                if(Math.abs(l - r) > 1){
                    console.log("invalid state found!");

                    //fix the problem at this subtree
                    var k1 = this;
                    var k2, k3;
                    if(l - r > 0){
                        //left subtree is heavy
                        k2 = this.left;
                    }else{
                        //right subtree is heavy
                        k2 = this.right;
                    }

                    var l2 = -1;
                    var r2 = -1;
                    if(k2.left != null)
                        l2 = k2.left.getHeight();
                    if(k2.right != null)
                        r2 = k2.right.getHeight();

                    if(l2 - r2 > 0){
                        //left sub subtree is heavy
                        k3 = k2.left;
                    }else{
                        //right sub subtree is heavy
                        k3 = k2.right;
                    }

                    console.log("Nodes: ", k1, k2, k3);
                    
                }
                //have the parent continue validating
                if(this.parent)
                    this.parent.validateTree();
            }

            //starting over using parents

            insert(n){
                if(n.value <= this.value){
                    //check left side for insert location
                    if(this.left == null){
                        console.log("Inserted " + n.value + " as a left child of " + this.value);
                        n.parent = this;
                        this.left = n;
                        //check for validity
                        this.validateTree();
                    }else{
                        this.left.insert(n);
                    }
                }else{
                    //check right side for insert location
                    if(this.right == null){
                        console.log("Inserted " + n.value + " as a right child of " + this.value);
                        n.parent = this;
                        this.right = n;
                        //check for validity
                        this.validateTree();
                    }else{
                        this.right.insert(n);
                    }
                }
                root.display();
            }

            /*
            insert(n, path){
                path.unshift(this);
                if(n.value <= this.value){
                    if(this.left == null){
                        console.log("Inserted " + n.value + " as a left child of " + this.value);
                        path.unshift(n);
                        console.log(path);
                        this.left = n;

                        //check for validity
                        for(var i = 0; i < path.length; i++){
                            console.log(path[i].value + ":" + path[i].isValid());
                            if(!path[i].isValid()){
                                fixViolation(path[i], path[i-1], path[i-2]);
                            }
                        }
                    }else{
                        this.left.insert(n, path);
                    }
                }else{
                    if(this.right == null){
                        console.log("Inserted " + n.value + " as a right child of " + this.value);
                        path.unshift(n);
                        this.right = n;
                        console.log(path);

                        //check for validity
                        for(var i = 0; i < path.length; i++){
                            console.log(path[i].value + ":" + path[i].isValid());
                            if(!path[i].isValid()){
                                fixViolation(path[i], path[i-1], path[i-2]);
                            }
                        }
                    }else{
                        this.right.insert(n, path);
                    }
                }
            }

            //assumes a leaf node is being deleted, need to improve
            //if deleted node has left children replace with largest left
            //if no left replace with immediate right (or null if that is null)
            //including the newly replaced node, check along the path for violations
            delete(value, path){
                path.unshift(this);
                console.log("Delete Path checked: ", path);
                if(value <= this.value){
                    //investigate left subtree
                    if(this.left == null){
                        console.log("Could not delete " + value + " no such node");
                    }else{
                        //if there is a left child
                        if(this.left.value == value){
                            console.log("Deleting left child");
                            //if the left child is the node to delete
                            var toDelete = this.left; //seadep
                            
                            if(toDelete.left != null){
                                //if the left child has a left child get that as the replacement
                                console.log("Node to delete has a left child");
                                //get the highest left child of the deleted node and the path to it from the deleted node
                                var subPath = [];
                                var check = toDelete.left;
                                while(check.right != null){
                                    subPath.push(check);
                                    check = check.right;
                                }
                                //check is now the replacement node for toDelete
                                //it has no right child and therefore at most 1 left child
                                //subPath includes everything [left child -> replacement)
                                console.log("Replacement is:", check);
                                console.log("subpath is", subPath);
                                //set right child of check's paretnt to the left child of check
                                subPath[subPath.length - 1].right = check.left;
                                //fully replace the node to delete
                                this.left = check;
                                check.left = toDelete.left;
                                check.right = toDelete.right; 
                                //check is now fully integrated
                                
                                //update the path with check and the sub path
                                for(var i = 0; i< subPath.length; i++)
                                    path.unshift(subPath.pop());
                            }else{
                                //get the right child as the replacement
                                console.log("node to delete has no left child, replacing with:", toDelete.right);
                                this.left = toDelete.right;
                                path.unshift(this.left);
                            }

                        }else{
                            //if the left child is not the node to delete
                            this.left.delete(value, path);
                        }
                    }
                }else{
                    //investigate right subtree
                    if(this.right == null){
                        console.log("Could not delete " + value + " no such node");
                    }else{
                        //if there is a right node
                        if(this.right.value == value){
                            //if the right child is the node to delete
                        }else{
                            //if the right child is not the node to delete
                            this.right.delete(value, path);
                        }
                    }
                }
            }
            */
            /*delete(value, path){
                path.unshift(this);
                if(value <= this.value){
                    if(this.left == null){
                        console.log("Could not delete " + value + " no such node");
                    }else{
                        if(this.left.value == value){
                            this.left = null;
                            for(var i = 0; i < path.length; i++){
                                console.log(path[i].value + ":" + path[i].isValid());
                                if(!path[i].isValid()){
                                    var k1 = path[i];
                                    //get k2
                                    if(k1 === this || k1.left === path[i-1]){
                                        var k2 = k1.right;
                                    }else{
                                        var k2 = k1.left;
                                    }
                                    //get k3
                                    var k2l = -1;
                                    var k2r = -1;
                                    if(k2.left != null)
                                        k2l = k2.left.getHeight();
                                    if(k2.right != null)
                                        k2r = k2.right.getHeight();
                                    
                                    if(k2r >= k2l){
                                        var k3 = k2.right;
                                    }else{
                                        var k3 = k2.left;
                                    }
                                    fixViolation(k1,k2,k3);
                                }
                            }
                        }else{
                            this.left.delete(value,path);
                        }
                    }
                }else{
                    //value on right side
                    if(this.right == null){
                        console.log("Could not delete " + value + " no such node");
                    }else{
                        if(this.right.value == value){
                            this.right = null;
                            for(var i = 0; i < path.length; i++){
                            console.log(path[i].value + ":" + path[i].isValid());
                            if(!path[i].isValid()){
                                var k1 = path[i];
                                //get k2
                                if(k1.left === path[i-1]){
                                    var k2 = k1.right;
                                }else{
                                    var k2 = k1.left;
                                }
                                //get k3
                                var k2l = -1;
                                var k2r = -1;
                                if(k2.left != null)
                                    k2l = k2.left.getHeight();
                                if(k2.right != null)
                                    k2r = k2.right.getHeight();
                                
                                if(k2r >= k2l){
                                    var k3 = k2.right;
                                }else{
                                    var k3 = k2.left;
                                }
                                fixViolation(k1,k2,k3);
                            }
                        }
                        }else{
                            this.right.delete(value,path);
                        }
                    }
                }
            }*/
            
            display(){
                var v1 = this.value;
                var v2 = "null";
                var v3 = "null";

                if(this.left != null)
                    v2 = this.left.value;
                if(this.right != null)
                    v3 = this.right.value;

                console.log(v1 + ":" + v2 + "," + v3);
                if(this.left != null)
                    this.left.display();
                if(this.right != null)
                    this.right.display();
            }
        }

        function fixViolation(k1, k2, k3){
            console.log(k1, k2, k3);
            //find the relationship between k1 and k2
            var firstIsRight = (k1.right === k2);
            var secondIsRight = (k2.right === k3);
            
            if(firstIsRight && secondIsRight){
                //Right right rotation
                console.log("RR rotation");
                temp = k2.left;
                k2.left = k1;
                k1.right = temp;
                if(root === k1)
                    root = k2;
                k2.display();
            }else if(firstIsRight && !secondIsRight){
                //Right left rotation
                console.log("RL rotation");
                temp1 = k3.left;
                temp2 = k3.right;
                k3.left = k1;
                k3.right = k2;
                k1.right = temp1;
                k2.left = temp2;
                if(root === k1)
                    root = k3;
                k3.display();
            }else if(!firstIsRight && secondIsRight){
                //Left Right rotation
                console.log("LR rotation");
                temp1 = k3.left;
                temp2 = k3.right;
                k3.right = k1;
                k3.left = k2;
                k2.right = temp1;
                k1.left = temp2;
                if(root === k1)
                    root = k3;
                k3.display();
            }else{
                //Left left rotation
                console.log("LL rotation");
                console.log("start", k1, k2, root);
                temp = k2.right;
                k2.right = k1;
                k1.left = temp;
                
                if(root === k1){
                    console.log("Changing root from " + k1.value + " to " + k2.value)
                    root = k2;

                }
                
                console.log("end", k1, k2, root);

                k2.display();
            }
        }

    </script>
</body>
</html>

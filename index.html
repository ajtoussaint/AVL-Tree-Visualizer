<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AVL Tree Visualizer</title>
    <!--By Andrew Toussaint-->

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        #svgWrap{
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #mainSvg {
            width: 90vw;
            height: 80vh;
            overflow: visible;
        }

    </style>
</head>

<body>
    <h1>AVL Tree Visualizer</h1>
    <div>
        <input type="text" id="insert"/>
        <button id="insertButton">
            Insert
        </button>

        <input type="text" id="delete"/>
        <button id="deleteButton">
            Delete
        </button>

        <input type="text" id="find"/>
        <button id="findButton">
            Find
        </button>

        <button id="clearButton">
            Clear
        </button>

        <input type="text" id="random" placeholder="# of keys to add"/>
        <button id="randomButton">
            Random Tree
        </button>

        <label for="speed">Animation speed:</label>
        <select id="speed" name="speed">
            <option value=2000>Slow</option>
            <option value=500 selected>Normal</option>
            <option value=50>Fast</option>
            <option value=0>Instant</option>
        </select>

        <label for="inputType">Input type:</label>
        <select id="inputType" name="inputType">
            <option value='number' selected>Numerical</option>
            <option value='string' >Character</option>
        </select>

    </div>
    <div id="message">

    </div>
    <div id="svgWrap">
        <svg id="mainSvg" width="600px" height="400px">

        </svg>
    </div>
    

    <script>
        //https://stackoverflow.com/questions/3642035/jquerys-append-not-working-with-svg-element <-- Source for svg making stuff
        function addShape(tag, attrs){
            var el= document.createElementNS('http://www.w3.org/2000/svg', tag);
            for (var k in attrs)
                el.setAttribute(k, attrs[k]);
            document.getElementById('mainSvg').appendChild(el);
        }

        function addText(text, attrs){
            var el= document.createElementNS('http://www.w3.org/2000/svg', "text");
            for (var k in attrs)
                el.setAttribute(k, attrs[k]);
            
            el.textContent = text;

            document.getElementById('mainSvg').appendChild(el);
        }

        const nodeRadius = 20;
        const nodeEdge = Math.sqrt(Math.pow(nodeRadius, 2)/2);

        var root = null;
        var nodeIdCounter = 0;
        var lineIdCounter = 0;
        var canSubmit = true;
        var animationSpeed = 500;
        var inputType = "number";

        function addNode(value, x, y){
            var nodeClass = "node_" + nodeIdCounter
            addShape("circle", {cx:x, cy:y, r:nodeRadius, stroke:"black", "stroke-width":3, fill:"white", id:"circle_"+nodeIdCounter, class:nodeClass});
            addText(value, {x:x, y:y, "text-anchor":"middle", "dominant-baseline":"middle", "font-family":"monospace", "font-size":"20", "fill":"black", id:"text_" + nodeIdCounter, class:nodeClass});
            nodeIdCounter += 1;
            return "." + nodeClass;
        }

        function createInspector(){
            //begins inspector over the root
            addShape("circle", {cx:$('#mainSvg').width()/2, cy:50, r:nodeRadius + 2.5, stroke:"blue", "stroke-width":5, fill:"none", id:"inspector"});
            return "#inspector";
        }

        function createLine(x1, y1, x2, y2){
            var str = "line_" + lineIdCounter;
            addShape("line", {x1:x1, y1:y1, x2:x2, y2:y2, stroke:"black", "stroke-width":"3", id:str})
            lineIdCounter += 1;
            return "#" + str;
        }

        async function translateElements(identifier, x, y){
            const duration = parseInt(animationSpeed); //animation time in ms, controlled by dropdown
            els = $(identifier);

            els.each((i, p) => {
                el = $(p);
                var old_x = el.attr("x") ?? el.attr("cx");
                var old_y = el.attr("y") ?? el.attr("cy");

                const animation = p.animate(
                    [
                        {transform: `translate(0,0)`},
                        {transform: `translate(${x-old_x}px, ${y - old_y}px)`}
                    ],
                    {
                        duration: duration,
                        fill: 'forwards'
                    }
                )                    
            });
            
            await new Promise(r => setTimeout(r,duration));

            //after animation is complete clone the elements in the new location and delete the old ones
            els.each((i,p) => {
                el = $(p);
                var cl = el.clone();
                if(cl.attr("x") !== undefined){
                    cl.attr("x", x);
                    cl.attr("y", y);
                }else{
                    cl.attr("cx", x);
                    cl.attr("cy", y);
                }
                el.after(cl);
                el.remove();
            })

            //small timeout to buffer next animation
            await new Promise(r => setTimeout(r,animationSpeed));
        }

        async function moveLine(identifier, x1, y1, x2, y2, duration=animationSpeed){
            el = $(identifier);
            const old_x1 = parseFloat(el.attr("x1"));
            const old_y1 = parseFloat(el.attr("y1"));
            const old_x2 = parseFloat(el.attr("x2"));
            const old_y2 = parseFloat(el.attr("y2"));

            const dx1 = x1 - old_x1;
            const dy1 = y1 - old_y1;
            const dx2 = x2 - old_x2;
            const dy2 = y2 - old_y2;

            const startTime = performance.now();

            function animateLine(time) {
                const elapsed = time - startTime;
                const progress = Math.min(elapsed / duration, 1);

                el.attr("x1", old_x1 + dx1 * progress);
                el.attr("y1", old_y1 + dy1 * progress);
                el.attr("x2", old_x2 + dx2 * progress);
                el.attr("y2", old_y2 + dy2 * progress);

                if (progress < 1) {
                    requestAnimationFrame(animateLine);
                }
            }

            requestAnimationFrame(animateLine);

            await new Promise(r => setTimeout(r,duration));//wait for animation to finish

            var cl = el.clone()
            cl.attr({x1:x1, y1:y1, x2:x2, y2:y2});
            el.after(cl);
            el.remove();
            console.log(identifier + " line move complete");
            await new Promise(r => setTimeout(r,duration));
            console.log(identifier + " buffer complete");
        }

        $(document).ready(function() {
            const message = $("#message");

            $("#insertButton").click(async function() {
                if(canSubmit){
                    canSubmit = false;
                    var value = $("#insert").val();
                    if(inputType == "number"){
                        value = parseFloat(value);
                        if(isNaN(value)){
                        message.text("Invalid input, change input type to use characters")
                        canSubmit = true;
                        return;
                        }
                    }
                        
                    $("#insert").val('');

                    //place a node with the value at the staging area
                    var nodeClass = addNode(value, 0, 100);
                    message.text("Adding node: " + value);
                    //pause for dramatic effect
                    await new Promise(r => setTimeout(r,animationSpeed));
                    const n = new Node(value, null, nodeClass);
                    if(root == null){
                        message.text("Adding new node at the root: " + n.value);
                        //move the node to the root location
                        await translateElements(nodeClass, $('#mainSvg').width()/2 ,50);
                        root = n;
                        canSubmit = true;
                    }else{
                        createInspector();
                        root.insert(n);
                    }
                }
            });

            $("#deleteButton").click(async function(){
                if(canSubmit){
                    canSubmit = false;

                    var value = $("#delete").val();
                    if(inputType == "number"){
                        value = parseFloat(value);
                        if(isNaN(value)){
                        message.text("Invalid input, change input type to use characters")
                        canSubmit = true;
                        return;
                        }
                    }
                    $("#delete").val('');
                    $("#message").text("Deleting " + value);

                    if(root != null){
                        createInspector();
                        root.delete(value);
                    }else{
                        $("#message").text("No nodes in tree!");
                        canSubmit = true;
                    }
                }
            });

            $("#findButton").click(async function(){
                if(canSubmit){
                    canSubmit = false;
                    var value = $('#find').val();
                    if(inputType == "number"){
                        value = parseFloat(value);
                        if(isNaN(value)){
                        message.text("Invalid input, change input type to use characters")
                        canSubmit = true;
                        return;
                        }
                    }
                    if(root){
                        createInspector();
                        root.find(value);
                    }else{
                        $("#message").text("No nodes in tree!");
                        canSubmit = true;
                    }
                    $("#find").val('');
                }
                
            });

            $("#clearButton").click(function(){
                root = null;
                //remove all svg children
                $('#mainSvg').empty();
            });

            $("#randomButton").click(async function(){
                if(canSubmit){
                    canSubmit = false;
                    //clear the existing tree
                    root = null;
                    //remove all svg children
                    $('#mainSvg').empty();

                    var n = $("#random").val();
                    $("#random").val('');

                    n = parseInt(n, 10);

                    //generate n random integers
                    let max = 999;
                    let min = -999;
                    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-_=+[]{}|;:,.<>?';

                    const randomValues = [];

                    if(inputType === "number"){
                       for (let i = 0; i < n; i++) {
                            const randomInt = Math.floor(Math.random() * (max - min + 1)) + min;
                            randomValues.push(randomInt);
                        } 
                    }
                    else{
                        for(var i = 0; i < n; i++){    
                            var randomStr = '';
                            const randomStrLen = Math.floor(Math.random() * 3) + 1;
                            for (let j = 0; j < randomStrLen; j++){
                                randomStr += characters.charAt(Math.floor(Math.random() * characters.length));
                            }
                            randomValues.push(randomStr);
                        }
                    }
                    

                    console.log(randomValues);

                    async function insertValue(v){
                        //insert the int into the tree

                        //place a node with the value at the staging area
                        var nodeClass = addNode(v, 0, 100);
                        message.text("Adding node: " + v);
                        //pause for dramatic effect
                        await new Promise(r => setTimeout(r,animationSpeed));
                        const n = new Node(v, null, nodeClass);
                        if(root == null){
                            message.text("Adding new node at the root: " + n.value);
                            //move the node to the root location
                            await translateElements(nodeClass, $('#mainSvg').width()/2 ,50);
                            root = n;
                            canSubmit = true;
                        }else{
                            createInspector();
                            await root.insert(n);
                            canSubmit = false;
                        }
                    }
                    
                    for (const v of randomValues){
                        console.log("inserting " + v);
                        await insertValue(v);
                    }

                    canSubmit=true;
                    
                }
            });

            $("#speed").change(function(){
                console.log("speed is " + $(this).val());
                animationSpeed = $(this).val();
            })

            $("#inputType").change(function(){
                //clear the existing tree
                root = null;
                    //remove all svg children
                $('#mainSvg').empty();

                console.log("type is " + $(this).val());
                inputType = $(this).val();
            })
        });

        class Node {
            constructor(value, parent, nodeClass){
                this.value = value;
                this.left = null;
                this.right = null;
                this.parent = parent;
                this.class = nodeClass;
                this.id = this.class.substring(this.class.indexOf('_') + 1)
                this.leftLineId = null;
                this.rightLineId = null;
            }

            getHeight(){
                var l = -1;
                var r = -1;
                if(this.left != null)
                    l = this.left.getHeight();
                if(this.right != null)
                    r = this.right.getHeight();
                if(l > r){
                    return l + 1;
                }else{
                    return r + 1;
                }
            }

            getBalance(){
                var l = -1;
                var r = -1;
                if(this.left != null)
                    l = this.left.getHeight();
                if(this.right != null)
                    r = this.right.getHeight();

                return l - r; //positive = left tree heavy, negative = right tree heavy, 0 = balanced
            }

            getX(){
                return parseFloat($("#text_" + this.id).attr('x'));
            }

            getY(){
                return parseFloat($("#text_" + this.id).attr('y'));
            }

            leftChildX(){
                return this.parent ? this.getX() - Math.abs(this.getX() - this.parent.getX())/2 : this.getX() / 2;
            }

            rightChildX(){
                return this.parent ? this.getX() + Math.abs(this.getX() - this.parent.getX())/2 : this.getX() * 1.5;
            }

            async validateTree(){
                const message = $("#message");
                message.text("Validating subtree at node " + this.value);

                //move the inspector to this element for validation
                await translateElements('#inspector', this.getX(), this.getY());

                var balance = this.getBalance();

                if(Math.abs(balance) > 1){
                    $("#inspector").attr("stroke", "red");
                    message.text("Subtree at node " + this.value + " is invalid!");
                    //fix the problem at this subtree
                    var k1 = this;
                    var k2, k3;
                    if(balance > 0){
                        //left subtree is heavy
                        k2 = this.left;
                        //set the left path color to red
                        $(this.leftLineId).attr("stroke", "red");
                    }else{
                        //right subtree is heavy
                        k2 = this.right;
                        $(this.rightLineId).attr("stroke", "red");
                    }

                    var balance2 = k2.getBalance();

                    if(balance2 > 0){
                        //left sub subtree is heavy
                        k3 = k2.left;
                        $(k2.leftLineId).attr("stroke", "red");
                    }else{
                        //right sub subtree is heavy
                        k3 = k2.right;
                        $(k2.rightLineId).attr("stroke", "red");
                    }

                    //pause to show the user the state
                    await new Promise(r => setTimeout(r,animationSpeed));

                    console.log("Validate Tree has chosen these nodes to fix a violation: ", k1, k2, k3);
                    await fixViolation(k1, k2, k3);
                    $("#inspector").attr("stroke", "blue"); //violation fixed, set inspector blue 
                }
                //have the parent continue validating
                if(this.parent){
                    await this.parent.validateTree();
                }else{
                    message.text("Done")
                    $("#inspector").remove()
                }     
            }

            async find(v){
                const message = $("#message");
                if(v < this.value){
                    message.text(v + '<=' + this.value);
                    await translateElements("#inspector", this.leftChildX(), 100 + this.getY());
                    if(this.left == null){
                        //node does not exist
                        $("#inspector").attr('stroke', 'red');    
                        message.text(v + " could not be found");
                        //pause for effect
                        await new Promise(r => setTimeout(r,animationSpeed));
                        //remove inspector
                        $("#inspector").remove();
                        canSubmit = true;
                    }else{
                        this.left.find(v);
                    }
                }else if(v > this.value){
                    message.text(v + ">" + this.value);
                    await translateElements("#inspector", this.rightChildX(), 100 + this.getY());
                    if(this.right == null){
                        //node does not exist
                        $("#inspector").attr('stroke', 'red');    
                        message.text(v + " could not be found");
                        //pause for effect
                        await new Promise(r => setTimeout(r,animationSpeed));
                        //remove inspector
                        $("#inspector").remove();
                        canSubmit = true;
                    }else{
                        this.right.find(v);
                    }
                }else{
                    //this is the node were looking for
                    message.text("Found " + v);
                    $("#inspector").attr('stroke', 'green');
                    //pause for effect
                    await new Promise(r => setTimeout(r,animationSpeed));
                    //delete inspector
                    $("#inspector").remove();
                    canSubmit = true;
                }
            }


            async insert(n){
                const message = $("#message");
                if(n.value <= this.value){
                    //check left side for insert location
                    message.text(n.value + '<=' + this.value);
                    //move inspector to where the left child would be
                    await translateElements("#inspector", this.leftChildX(), 100 + this.getY());
                    if(this.left == null){
                        message.text("Inserting node left of: " + this.value);
                        n.parent = this;
                        this.left = n;
                        //move the waiting node to the insertion location
                        await translateElements(n.class, this.leftChildX(), 100 + this.getY());
                        //create a branch between the two
                        this.leftLineId = createLine(this.getX() - nodeEdge, this.getY() + nodeEdge, this.leftChildX() + nodeEdge, 100 + this.getY() - nodeEdge);
                        //check for validity
                        await this.validateTree();
                        console.log("inserted " + n.value + " as left child of " + this.value);
                        canSubmit = true;
                    }else{
                        await this.left.insert(n);
                    }
                }else{
                    //check right side for insert location
                    message.text(n.value + '>' + this.value);
                    //move inspector to where the right child would be
                    await translateElements("#inspector", this.rightChildX(), 100 + this.getY());
                    if(this.right == null){
                        message.text("Inserting node right of: " + this.value);
                        n.parent = this;
                        this.right = n;
                        //move the waiting node to the insertion location
                        await translateElements(n.class, this.rightChildX(), 100 + this.getY());
                        //create a branch between the two
                        this.rightLineId = createLine(this.getX() + nodeEdge, this.getY() + nodeEdge, this.rightChildX() - nodeEdge, 100 + this.getY() - nodeEdge);
                        //check for validity
                        await this.validateTree();
                        console.log("inserted " + n.value + " as left child of " + this.value);
                        canSubmit = true;
                    }else{
                        await this.right.insert(n);
                    }
                }
            }

            async delete(v){
                const message = $("#message");
                //go until you are the node to delete
                if(this.value == v){
                    //delete this node
                    console.log("Found node to delete: " + this.value);
                    //remove this nodes visual
                    var old_x = this.getX();
                    var old_y = this.getY();
                    $(this.class).remove();
                    if(this.parent){
                        if(this.parent.value < this.value){
                            $(this.parent.rightLineId).remove()
                        }else{
                            $(this.parent.leftLineId).remove()
                        }
                    }
                    await new Promise(r => setTimeout(r,animationSpeed));
                    var validator;
                    if (this.left){
                        console.log("replacing with left child");
                        message.text("Finding largest node in left subtree as replacement");
                        //if the toDelete node has a left child replace it with the largest node in the left subtree
                        var largestLeft = this.left;
                        await translateElements("#inspector", this.left.getX(), this.left.getY());
                        while(largestLeft.right != null){
                            largestLeft = largestLeft.right;
                            await translateElements("#inspector", largestLeft.getX(), largestLeft.getY());
                        }
                        message.text("Largest left node is " + largestLeft.value);
                        //when the largest node is found, replace THAT node with ITS direct left child (may be null)
                        if(largestLeft.parent.right === largestLeft){
                            //largest left is right child of its parent
                            console.log("ll is a right child");
                            $(largestLeft.parent.rightLineId).remove();
                            largestLeft.parent.right = largestLeft.left;
                        }else{
                            //largest left is left child of its parent
                            $(largestLeft.parent.leftLineId).remove();
                            largestLeft.parent.left = largestLeft.left;
                        }
                        //delete ll's connection to child
                        if(largestLeft.left)
                            $(largestLeft.leftLineId).remove();
                        //save ll's current location to move its child
                        var llx = largestLeft.getX();
                        var lly = largestLeft.getY();

                        //move the largest left node to this nodes previous locaiton
                        await translateElements(largestLeft.class, old_x, old_y);

                        if(largestLeft.left){
                            if(largestLeft.parent !== this)
                                largestLeft.left.parent = largestLeft.parent;
                            await translateElements(largestLeft.left.class, llx, lly);
                            //in case largest left is till the parent of its left child
                            if(largestLeft.left.parent.value >= largestLeft.left.value){
                                largestLeft.left.parent.leftLineId = createLine(largestLeft.left.parent.getX() - nodeEdge, largestLeft.left.parent.getY() + nodeEdge, llx + nodeEdge, lly - nodeEdge);
                            }else{
                                largestLeft.left.parent.rightLineId = createLine(largestLeft.left.parent.getX() + nodeEdge, largestLeft.left.parent.getY() + nodeEdge, llx - nodeEdge, lly - nodeEdge);
                            }
                            //console.log("Seeting valiator to the left child of LL");
                            validator = largestLeft.left;
                        }else if(largestLeft.parent !== this){
                            //console.log("Setting validator to the parent of LL");
                            validator = largestLeft.parent;
                        }else{
                            //console.log("Setting validator to LL")
                            validator = largestLeft;
                        }
                        //then place the largst left node in this existing node's place
                        largestLeft.parent = this.parent;
                        largestLeft.left = this.left;
                        largestLeft.right = this.right;
                        if(this.left){
                            this.left.parent = largestLeft;
                            largestLeft.leftLineId = this.leftLineId;
                        }
                        if(this.right){
                            this.right.parent = largestLeft;
                            largestLeft.rightLineId = this.rightLineId;
                        }
 
                        if(this.parent && this === this.parent.right){
                            //I am a right child
                            this.parent.rightLineId = createLine(this.parent.getX() + nodeEdge, this.parent.getY() + nodeEdge, this.parent.rightChildX() - nodeEdge, this.parent.getY() +100 - nodeEdge);
                            this.parent.right = largestLeft;
                        }else if(this.parent){
                            //I am a left child
                            this.parent.leftLineId = createLine(this.parent.getX() - nodeEdge, this.parent.getY() + nodeEdge, this.parent.leftChildX() + nodeEdge, this.parent.getY() + 100 - nodeEdge);
                            this.parent.left = largestLeft;
                        }else{
                            //I am root
                            root = largestLeft;
                        }
                        //validate from the replacement node's parent (validator runs at end of next else statement)
                    }else{
                        if(this.right){
                            $(this.rightLineId).remove();
                            await this.right.bringChildren(old_x, old_y);
                        }
                        //replace this node with its right child node (may be null)
                        if(this.parent && this == this.parent.right){
                            //I am a right child
                            this.parent.right = this.right;
                            if(this.right){
                                this.right.parent = this.parent;
                                this.parent.rightLineId = createLine(this.parent.getX() + nodeEdge, this.parent.getY() + nodeEdge, this.parent.rightChildX() - nodeEdge, this.parent.getY() +100 - nodeEdge);
                            }else{
                                $(this.parent.rightLineId).remove();
                            }
                        }else if(this.parent){
                            //I am a left child
                            this.parent.left = this.right;
                            if(this.right){
                                this.right.parent = this.parent;
                                this.parent.leftLineId = createLine(this.parent.getX() - nodeEdge, this.parent.getY() + nodeEdge, this.parent.leftChildX() + nodeEdge, this.parent.getY() + 100 - nodeEdge);
                            }else{
                                $(this.parent.leftLineId).remove();
                            }
                        }else{
                            //I am root
                            this.right.parent = this.parent;
                            root = this.right;
                        }
                        //validate from this node up
                        if(this.right){
                            validator = this.right;
                        }
                        else if(this.parent){
                            validator = this.parent;
                        }
                        else{
                            validator = null;
                        }
                    }

                    if(validator)
                        await validator.validateTree();
                    else
                        $("#inspector").remove();

                    canSubmit = true;
                }else if(v < this.value && this.left != null){
                    //look to the left
                    message.text(v + "<" + this.value);
                    await translateElements("#inspector", this.leftChildX(), 100 + this.getY());
                    this.left.delete(v);
                }else if(v > this.value && this.right != null){
                    //look to the right
                    message.text(v + ">" + this.value);
                    await translateElements("#inspector", this.rightChildX(), 100 + this.getY());
                    this.right.delete(v);
                }else{
                    message.text("Value does not exist in tree");
                    canSubmit = true;
                    $("#inspector").remove();
                }   
            }

            //given a new translation destination for this node move it there 
            //along with all elements in the left subtree
            async bringLeft(x, y, cspace){
                //determine ascending or descending
                let ascending = y <= this.getY();
                //move this element to its specified location
                //tell its left child to move to the location to the left of this new one
                if(ascending){
                    //bring all the left childs children
                    await translateElements(this.class, x, y)

                    if(this.left){
                        //move the line and make it black (in case of violation)
                        $(this.leftLineId).attr("stroke", "black");
                        
                        //move the child to its position
                        var left_x = cspace ? x - cspace : this.leftChildX();
                        var left_y = y + 100;
                        await moveLine(this.leftLineId, x - nodeEdge, y + nodeEdge, left_x + nodeEdge , left_y - nodeEdge);
                        await this.left.bringChildren(left_x, left_y);
                    }
                }else{
                    //reverse order to move down
                    //calculate cpsace for child use
                    if(this.left){
                        //move the line and make it black (in case of violation)
                        $(this.leftLineId).attr("stroke", "black");
                        
                        //move the child to its position
                        var left_x = cspace ? x - cspace : this.leftChildX();
                        var left_y = y + 100;

                        let ccspace = Math.abs(left_x - x)/2;

                        await this.left.bringChildren(left_x, left_y, ccspace);
                        await moveLine(this.leftLineId, x - nodeEdge, y + nodeEdge, left_x + nodeEdge , left_y - nodeEdge);
                    }
                    await translateElements(this.class, x, y)
                }  
            }

            async bringChildren(x, y, cspace){
                let ascending = y <= this.getY();

                if(ascending){
                    await translateElements(this.class, x, y);

                    var left_x = cspace ? x - cspace : this.leftChildX();
                    var new_y = y + 100;
                    var right_x = cspace ? x + cspace : this.rightChildX();

                    if(this.right){
                        $(this.rightLineId).attr("stroke", "black");
                        await moveLine(this.rightLineId, x + nodeEdge, y + nodeEdge, right_x - nodeEdge , new_y - nodeEdge);
                        await this.right.bringChildren(right_x, new_y);
                    }

                    if(this.left){
                        $(this.leftLineId).attr("stroke", "black");
                        await moveLine(this.leftLineId, x - nodeEdge, y + nodeEdge, left_x + nodeEdge , new_y - nodeEdge);
                        await this.left.bringChildren(left_x, new_y);
                    } 
                }else{
                    //descending
                    var left_x = cspace ? x - cspace : this.leftChildX();
                    var new_y = y + 100;
                    var right_x = cspace ? x + cspace : this.rightChildX();

                    //calculate cpsace for child use
                    let ccspace = Math.abs(right_x - x)/2;
                    //reverse order to move down
                    if(this.right){
                        $(this.rightLineId).attr("stroke", "black");
                        await this.right.bringChildren(right_x, new_y, ccspace);
                        await moveLine(this.rightLineId, x + nodeEdge, y + nodeEdge, right_x - nodeEdge , new_y - nodeEdge);
                    }

                    if(this.left){
                        $(this.leftLineId).attr("stroke", "black");
                        await this.left.bringChildren(left_x, new_y, ccspace);
                        await moveLine(this.leftLineId, x - nodeEdge, y + nodeEdge, left_x + nodeEdge , new_y - nodeEdge);
                    } 
                    await translateElements(this.class, x, y);
                }          
            }

            async bringRight(x,y, cspace){
                let ascending = y <= this.getY();

                if(ascending){
                    await translateElements(this.class, x, y)

                    if(this.right){
                        $(this.rightLineId).attr("stroke", "black");

                        //use predefined cspace in case parent is out of position to calculate rightChildX
                        var right_x = cspace ? x + cspace : this.rightChildX();                    
                        var right_y = y + 100;

                        await moveLine(this.rightLineId, x + nodeEdge, y + nodeEdge, right_x - nodeEdge , right_y - nodeEdge);
                        await this.right.bringChildren(right_x, right_y);
                    }
                }else{
                    //calculate cpsace for child use
                    if(this.right){
                        $(this.rightLineId).attr("stroke", "black");

                        //use predefined cspace in case parent is out of position to calculate rightChildX
                        var right_x = cspace ? x + cspace : this.rightChildX();                    
                        var right_y = y + 100;

                        let ccspace = Math.abs(right_x - x)/2;

                        await this.right.bringChildren(right_x, right_y, ccspace);//descending
                        await moveLine(this.rightLineId, x + nodeEdge, y + nodeEdge, right_x - nodeEdge , right_y - nodeEdge);
                    }
                    await translateElements(this.class, x, y)
                }
            }
        }

        async function fixViolation(k1, k2, k3){
            const message = $("#message");
            //find the relationship between k1 and k2
            var firstIsRight = (k1.right === k2);
            var secondIsRight = (k2.right === k3);
            var temp, temp1, temp2;
            
            if(firstIsRight && secondIsRight){
                console.log("RR rotate");
                //Right right rotation
                message.text("Performing a Right-Right rotation to fix the violaiton");
                //remove lines connected to k1s parent
                if(k1.parent){
                    if(k1 === k1.parent.right){
                        //k1 is a right child
                        $(k1.parent.rightLineId).remove();
                    }else{
                        $(k1.parent.leftLineId).remove();
                    }
                }
                //remove k1s right child line
                $(k1.rightLineId).remove();

                //calculate new positions
                //k1 moves to the spot for its left child
                var k1x = k1.leftChildX();
                var k1y = k1.getY() + 100;
                //k2 moves to k1s current position
                var k2x = k1.getX();
                var k2y = k1.getY();
                //if k2 has left child it will need to move later
                var k2l  = k2.left;
                
                //apply background logic
                temp = k2.left;
                k2.left = k1;
                k1.right = temp;
                if(temp)
                    temp.parent = k1;
                
                k2.parent = k1.parent;
                k1.parent = k2;

                if(root === k1){
                    root = k2;
                }else if(k2 === k2.parent.left){
                    //k2 is the left child of its parent
                    k2.parent.right = k2;
                }else{
                    k2.parent.left = k2;
                }

                //calculate cspace for k1 to move its children appropriately
                var cspace = Math.abs(k1.getX() - k1x)/2;
                await k1.bringLeft(k1x, k1y, cspace);

                //move k2 to k1s old spot along with its right subtree
                if(k2.leftLineId){
                    $(k2.leftLineId).remove();
                }

                await translateElements(k2.class, k2x, k2y);

                //k2s left child moves to be k1s right child in k1s new position
                if(k2l){
                    await k2l.bringChildren(k1.rightChildX(), k1.getY() + 100)//lateral
                    k1.rightLineId = createLine(k1.getX() + nodeEdge, k1.getY() + nodeEdge, k2l.getX() - nodeEdge, k2l.getY() - nodeEdge);
                }

                await k2.bringRight(k2x, k2y);//always goes up

                //create new leftchild line for k2
                k2.leftLineId = createLine(k2.getX() - nodeEdge, k2.getY() + nodeEdge, k2.leftChildX() + nodeEdge, k2.getY() + 100 - nodeEdge)

                //restor k2s new parent line if necessary
                if(k2.parent){
                    if(k2.value > k2.parent.value){
                        //k2 is right child
                        k2.parent.rightLineId = createLine(k2.parent.getX() + nodeEdge, k2.parent.getY() + nodeEdge, k2.getX() - nodeEdge, k2.getY() - nodeEdge);
                    }else{  
                        //k2 is left child
                        k2.parent.leftLineId = createLine(k2.parent.getX() - nodeEdge, k2.parent.getY() + nodeEdge, k2.getX() + nodeEdge, k2.getY() - nodeEdge);
                    }
                }
                
            }else if(firstIsRight && !secondIsRight){
                console.log("RL rotate");
                //Right left rotation
                message.text("Performing a Right-Left rotation to fix the violation");

                //remove the right line and parent line connected to k1:
                if(k1.parent){
                    if(k1.value > k1.parent.value){
                        $(k1.parent.rightLineId).remove();
                    }else{
                        $(k1.parent.leftLineId).remove();
                    }
                }
                $(k1.rightLineId).remove();

                //move k1 to the location of its left child
                var k1x = k1.leftChildX();
                var k1y = k1.getY() + 100;

                //move k3 to k1s old spot
                var k3x = k1.getX();
                var k3y = k1.getY();

                //if k3 has a right child it will become k2s left child
                var k3r = k3.right;
                //if k3 has a left child it will become k1s right child
                var k3l = k3.left;

                //apply backend logic
                temp1 = k3.left;
                temp2 = k3.right;
                k3.left = k1;
                k3.right = k2;
                
                k3.parent = k1.parent
                k1.parent = k3;
                k2.parent = k3;

                k1.right = temp1;
                if(temp1)
                    temp1.parent = k1;
                
                k2.left = temp2;
                if(temp2)
                    temp2.parent = k2;

                if(root === k1){
                    root = k3;
                }else if(k3.parent.value < k3.value){
                    k3.parent.right = k3;
                }else{
                    k3.parent.left = k3;
                }

                //apply animations
                //calculate space between k1 and  child
                var cspace = Math.abs(k1.getX() - k1x)/2;
                //move k1 to its locaiton along with its left child
                await k1.bringLeft(k1x, k1y, cspace);
                //move k3 to k1s old spot
                if(k3.rightLineId){
                    $(k3.rightLineId).remove();
                }
                if(k3.leftLineId){
                    $(k3.leftLineId).remove();
                }
                $(k2.leftLineId).remove();
                await translateElements(k3.class, k3x, k3y);
                //create child lines for k3
                k3.rightLineId = createLine(k3.getX() + nodeEdge, k3.getY() + nodeEdge, k3.rightChildX() - nodeEdge, 100 + k3.getY() - nodeEdge);
                k3.leftLineId = createLine(k3.getX() - nodeEdge, k3.getY() + nodeEdge, k3.leftChildX() + nodeEdge, 100 + k3.getY() - nodeEdge);
                //if k1 had a parent restore that line
                if(k3.parent){
                    if(k3.value > k3.parent.value){
                        //k3 is right child
                        k3.parent.rightLineId = createLine(k3.parent.getX() + nodeEdge, k3.parent.getY() + nodeEdge, k3.getX() - nodeEdge, k3.getY() - nodeEdge);
                    }else{  
                        //k3 is left child
                        k3.parent.leftLineId = createLine(k3.parent.getX() - nodeEdge, k3.parent.getY() + nodeEdge, k3.getX() + nodeEdge, k3.getY() - nodeEdge);
                    }
                }
                //move k3s left child to be k1's right child
                if(k3l){
                    await k3l.bringChildren(k1.rightChildX(), k1.getY() + 100);//ascending
                    k1.rightLineId = createLine(k1.getX() + nodeEdge, k1.getY() + nodeEdge, k1.rightChildX() - nodeEdge, k1.getY() + 100 - nodeEdge);
                }
                if(k3r){
                    await k3r.bringChildren(k2.leftChildX(), k2.getY() + 100);//ascending
                    k2.leftLineId = createLine(k2.getX() - nodeEdge, k2.getY() + nodeEdge, k2.leftChildX() + nodeEdge, k2.getY() + 100 - nodeEdge)
                }
            }else if(!firstIsRight && secondIsRight){
                console.log("LR rotate");
                //Left Right rotation
                message.text("Performing a Left-Right rotation to fix the violation");

                //remove the left line and parent line connected to k1
                if(k1.parent){
                    if(k1.value > k1.parent.value){
                        $(k1.parent.rightLineId).remove();
                    }else{
                        $(k1.parent.leftLineId).remove();
                    }
                }
                $(k1.leftLineId).remove();

                //move k1 to the location of its right child
                var k1x = k1.rightChildX();
                var k1y = k1.getY() + 100;

                //move k3 to k1s old spot
                var k3x = k1.getX();
                var k3y = k1.getY();

                //remember k3's current children
                var k3r = k3.right;
                var k3l = k3.left;

                //apply backend logic
                temp1 = k3.left;
                temp2 = k3.right;
                k3.right = k1;
                k3.left = k2;

                k3.parent = k1.parent
                k1.parent = k3;
                k2.parent = k3;

                k2.right = temp1;
                if(temp1)
                    temp1.parent = k2;
                
                k1.left = temp2;
                if(temp2)
                    temp2.parent = k1;

                if(root === k1){
                    root = k3;
                }else if(k3.parent.value < k3.value){
                    k3.parent.right = k3;
                }else{
                    k3.parent.left = k3;
                }

                //apply animations
                var cspace = Math.abs(k1.getX() - k1x)/2;
                //move k1 to its new location along with right child
                await k1.bringRight(k1x, k1y, cspace);
                //move k3 to k1s old spot
                if(k3.rightLineId){
                    $(k3.rightLineId).remove();
                }
                if(k3.leftLineId){
                    $(k3.leftLineId).remove();
                }
                $(k2.rightLineId).remove();

                await translateElements(k3.class, k3x, k3y);

                //creaet child lines for k3
                k3.rightLineId = createLine(k3.getX() + nodeEdge, k3.getY() + nodeEdge, k3.rightChildX() - nodeEdge, 100 + k3.getY() - nodeEdge);
                k3.leftLineId = createLine(k3.getX() - nodeEdge, k3.getY() + nodeEdge, k3.leftChildX() + nodeEdge, 100 + k3.getY() - nodeEdge);
                //if k1 had a parent restore that line
                if(k3.parent){
                    if(k3.value > k3.parent.value){
                        //k3 is right child
                        k3.parent.rightLineId = createLine(k3.parent.getX() + nodeEdge, k3.parent.getY() + nodeEdge, k3.getX() - nodeEdge, k3.getY() - nodeEdge);
                    }else{  
                        //k3 is left child
                        k3.parent.leftLineId = createLine(k3.parent.getX() - nodeEdge, k3.parent.getY() + nodeEdge, k3.getX() + nodeEdge, k3.getY() - nodeEdge);
                    }
                }

                //move k3s old children to new spots
                if(k3l){
                    await k3l.bringChildren(k2.rightChildX(), k2.getY() + 100);//ascending
                    k2.rightLineId = createLine(k2.getX() + nodeEdge, k2.getY() + nodeEdge, k2.rightChildX() - nodeEdge, k2.getY() + 100 - nodeEdge);
                }
                if(k3r){
                    await k3r.bringChildren(k1.leftChildX(), k1.getY() +100);//ascending
                    k1.leftLineId = createLine(k1.getX() - nodeEdge, k1.getY() + nodeEdge, k1.leftChildX() + nodeEdge, k1.getY() + 100 - nodeEdge);
                }

            }else{
                console.log("LL rotate");
                //Left left rotation
                message.text("Performing a Left-Left rotation to fix the violation")

                //remove lines connected to k1s parent
                if(k1.parent){
                    if(k1.value > k1.parent.value){
                        $(k1.parent.rightLineId).remove();
                    }else{
                        $(k1.parent.leftLineId).remove();
                    }
                }

                //remove k1s left child line
                $(k1.leftLineId).remove()

                //calculate the location for each node to move to:

                //move k1 to the spot for its right child along with its right subtree
                var k1x = k1.rightChildX();
                var k1y = k1.getY() + 100;
                //before moving save its old position to be used by k2
                var k2x = k1.getX();
                var k2y = k1.getY();
                //if k2 has a right child it will need to move to be k1s left child
                var k2r = k2.right;
                                
                //apply the background logic
                temp = k2.right;
                k2.right = k1;
                k1.left = temp;
                if(temp)
                    temp.parent = k1;

                k2.parent = k1.parent;
                k1.parent = k2;
                
                if(root === k1){
                    root = k2;
                }else if(k2.parent.value < k2.value){
                    k2.parent.right = k2;
                }else{
                    k2.parent.left = k2;
                }

                //calculate space between k1 and its right child and use cspace argument <- parent out of poisiont
                var cspace = Math.abs(k1.getX() - k1x)/2;
                
                await k1.bringRight(k1x, k1y, cspace);
                //move k2 to k1's old spot with its left subtree
                if(k2.rightLineId){
                    $(k2.rightLineId).remove();
                }

                await translateElements(k2.class, k2x, k2y);

                //k2's right child moves to be k1's left child in k1's new position
                if(k2r){
                    //move k2's right child's subtree with it
                    await k2r.bringChildren(k1.leftChildX(),k1.getY() + 100)//lateral
                    k1.leftLineId = createLine(k1.getX() - nodeEdge, k1.getY() + nodeEdge, k2r.getX() + nodeEdge, k2r.getY() - nodeEdge);
                }

                await k2.bringLeft(k2x, k2y);//always goes up
                //create new right child line for k2
                k2.rightLineId = createLine(k2.getX() + nodeEdge, k2.getY() + nodeEdge, k2.rightChildX() - nodeEdge, 100 + k2.getY() - nodeEdge);
                //restore connection to k2s new parent if necessary
                if(k2.parent){
                    if(k2.value > k2.parent.value){
                        //k2 is right child
                        k2.parent.rightLineId = createLine(k2.parent.getX() + nodeEdge, k2.parent.getY() + nodeEdge, k2.getX() - nodeEdge, k2.getY() - nodeEdge);
                    }else{  
                        //k2 is left child
                        k2.parent.leftLineId = createLine(k2.parent.getX() - nodeEdge, k2.parent.getY() + nodeEdge, k2.getX() + nodeEdge, k2.getY() - nodeEdge);
                    }
                }
                

            }
            message.text("Violation Resolved");
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AVL Tree Visualizer</title>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <style>
        #svgWrap{
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #mainSvg {
            width: 90vw;
            height: 80vh;
            overflow: visible;
        }

    </style>
</head>

<body>
    <h1>AVL Tree Visualizer</h1>
    <div>
        <input type="text" id="insert"/>
        <button id="insertButton">
            Insert
        </button>

        <input type="text" id="delete"/>
        <button id="deleteButton">
            Delete
        </button>

        <input type="text" id="find"/>
        <button id="findButton">
            Find
        </button>

        <button id="clearButton">
            Clear
        </button>

        <button id="randomButton">
            Random Tree
        </button>

        <button id="addShapeButton">
            Add
        </button>

        <button id="moveShapeButton">
            move
        </button>

        <button id="deleteShapeButton">
            delete
        </button>
    </div>
    <div id="message">

    </div>
    <div id="svgWrap">
        <svg id="mainSvg" width="600px" height="400px">

        </svg>
    </div>
    

    <script>
        //https://stackoverflow.com/questions/3642035/jquerys-append-not-working-with-svg-element <-- Source for svg making stuff
        function addShape(tag, attrs){
            var el= document.createElementNS('http://www.w3.org/2000/svg', tag);
            for (var k in attrs)
                el.setAttribute(k, attrs[k]);
            document.getElementById('mainSvg').appendChild(el);
        }

        function addText(text, attrs){
            var el= document.createElementNS('http://www.w3.org/2000/svg', "text");
            for (var k in attrs)
                el.setAttribute(k, attrs[k]);
            
            el.textContent = text;

            document.getElementById('mainSvg').appendChild(el);
        }

        const nodeRadius = 20;
        const nodeEdge = Math.sqrt(Math.pow(nodeRadius, 2)/2);

        var root = null;
        var nodeIdCounter = 0;
        var lineIdCounter = 0;

        function addNode(value, x, y){
            var nodeClass = "node_" + nodeIdCounter
            addShape("circle", {cx:x, cy:y, r:nodeRadius, stroke:"black", "stroke-width":3, fill:"white", id:"circle_"+nodeIdCounter, class:nodeClass});
            addText(value, {x:x, y:y, "text-anchor":"middle", "dominant-baseline":"middle", "font-family":"monospace", "font-size":"20", "fill":"black", id:"text_" + nodeIdCounter, class:nodeClass});
            nodeIdCounter += 1;
            return "." +nodeClass;
        }

        function createInspector(){
            //begins inspector over the root
            addShape("circle", {cx:$('#mainSvg').width()/2, cy:50, r:nodeRadius + 2.5, stroke:"blue", "stroke-width":5, fill:"none", id:"inspector"});
            return "#inspector";
        }

        function createLine(x1, y1, x2, y2){
            var str = "line_"+lineIdCounter;
            addShape("line", {x1:x1, y1:y1, x2:x2, y2:y2, stroke:"black", "stroke-width":"3", id:str})
            lineIdCounter += 1;
            return str
        }

        async function translateElements(identifier, x, y){
            const duration = 500; //animation time in ms

            els = $(identifier);

            els.each((i, p) => {
                el = $(p);
                var old_x = el.attr("x") ?? el.attr("cx");
                var old_y = el.attr("y") ?? el.attr("cy");

                const animation = p.animate(
                    [
                        {transform: `translate(0,0)`},
                        {transform: `translate(${x-old_x}px, ${y - old_y}px)`}
                    ],
                    {
                        duration: duration,
                        fill: 'forwards'
                    }
                )                    
            });
            
            await new Promise(r => setTimeout(r,duration));

            //after animation is complete clone the elements in the new location and delete the old ones
            console.log("updating position of " + identifier + ": " + x + "," + y);
            els.each((i,p) => {
                el = $(p);
                var cl = el.clone();
                if(cl.attr("x") !== undefined){
                    cl.attr("x", x);
                    cl.attr("y", y);
                }else{
                    cl.attr("cx", x);
                    cl.attr("cy", y);
                }
                el.after(cl);
                el.remove();
            })
            //small timeout to buffer next animation
            await new Promise(r => setTimeout(r,500));
        }

        $(document).ready(function() {
            const message = $("#message");

            $("#insertButton").click(async function() {
                var value = $("#insert").val();
                value = parseInt(value, 10);
                $("#insert").val('');

                //place a node with the value at the staging area
                var nodeClass = addNode(value, 0, 100);
                message.text("Adding node: " + value);
                //pause for dramatic effect
                await new Promise(r => setTimeout(r,500));
                const n = new Node(value, null, nodeClass);
                if(root == null){
                    message.text("Adding new node at the root: " + n.value);
                    //move the node to the root location
                    await translateElements(nodeClass, $('#mainSvg').width()/2 ,50);
                    root = n;
                    root.display();
                }else{
                    createInspector();
                    root.insert(n);
                }
                
            });

            $("#deleteButton").click(function(){
                var value = $("#delete").val();
                value = parseInt(value, 10);
                if(root != null){
                    root.delete(value);
                }
                $("#delete").val('');
            });

            $("#findButton").click(function(){
                alert("Find clicked!");
            });

            $("#clearButton").click(function(){
                root = null;
            });

            $("#randomButton").click(function(){
                
                //temporary, displays all the nodes
                if(root != null)
                    root.display();
            });

            $("#addShapeButton").click(function(){
                console.log("Add shape clicked");
                var w = $("#mainSvg").width();
                var h = $("#mainSvg").height();
                addNode(9, 200, 200);
            });

            $("#moveShapeButton").click(async function(){
                console.log("move clicked");
                await translateElements(".node_0", 100, 100);
                
                await translateElements(".node_0", 300, 300);

                await translateElements(".node_0", 100, 300);

                await translateElements(".node_0", 400, 100);
                console.log("move all done");
            });

            $("#deleteShapeButton").click(function(){
                console.log("delete shape clicked");
                const node_parts = $(".node_0");
                node_parts.remove();
            })
        });

        class Node {
            constructor(value, parent, nodeClass){
                this.value = value;
                this.left = null;
                this.right = null;
                this.parent = parent;
                this.class = nodeClass;
                this.id = this.class.substring(this.class.indexOf('_') + 1)
                this.leftLineId = null;
                this.rightLineId = null;
            }

            getHeight(){
                var l = -1;
                var r = -1;
                if(this.left != null)
                    l = this.left.getHeight();
                if(this.right != null)
                    r = this.right.getHeight();
                if(l > r){
                    return l + 1;
                }else{
                    return r + 1;
                }
            }

            getBalance(){
                var l = -1;
                var r = -1;
                if(this.left != null)
                    l = this.left.getHeight();
                if(this.right != null)
                    r = this.right.getHeight();

                return r - l; //positive = right tree heavy, negative = left tree heavy, 0 = balanced
            }

            getX(){
                return parseFloat($("#text_" + this.id).attr('x'));
            }

            getY(){
                return parseFloat($("#text_" + this.id).attr('y'));
            }

            async validateTree(){
                const message = $("#message");
                message.text("Validating subtree at node " + this.value);
                //move the inspector to this element for validation
                await translateElements('#inspector', this.getX(), this.getY());

                var l = -1;
                var r = -1;
                if(this.left != null)
                    l = this.left.getHeight();
                if(this.right != null)
                    r = this.right.getHeight();

                if(Math.abs(l - r) > 1){
                    $("#inspector").attr("stroke", "red");
                    message.text("Subtree at node " + this.value + " is invalid!");

                    //fix the problem at this subtree
                    var k1 = this;
                    var k2, k3;
                    if(l - r > 0){
                        //left subtree is heavy
                        k2 = this.left;
                    }else{
                        //right subtree is heavy
                        k2 = this.right;
                    }

                    var l2 = -1;
                    var r2 = -1;
                    if(k2.left != null)
                        l2 = k2.left.getHeight();
                    if(k2.right != null)
                        r2 = k2.right.getHeight();

                    if(l2 - r2 > 0){
                        //left sub subtree is heavy
                        k3 = k2.left;
                    }else{
                        //right sub subtree is heavy
                        k3 = k2.right;
                    }

                    console.log("Nodes: ", k1, k2, k3);
                    fixViolation(k1, k2, k3);
                    
                }
                //have the parent continue validating
                if(this.parent){
                    this.parent.validateTree();
                }else{
                    $("#inspector").remove()
                }
                    
            }


            async insert(n){
                const message = $("#message");
                message.text('Checking node: ' + this.value + " for insertion spot");
                if(n.value <= this.value){
                    //check left side for insert location
                    message.text(n.value + '<=' + this.value);
                    //move inspector to where the left child would be
                    await translateElements("#inspector", this.getX() / 2, 100 + this.getY());
                    if(this.left == null){
                        message.text("Inserting node left of: " + this.value);
                        n.parent = this;
                        this.left = n;
                        //move the waiting node to the insertion location
                        await translateElements(n.class, this.getX() / 2, 100 + this.getY());
                        //create a branch between the two
                        createLine(this.getX() - nodeEdge, this.getY() + nodeEdge, this.getX()/2 + nodeEdge, 100 + this.getY() - nodeEdge);
                        //check for validity
                        this.validateTree();
                    }else{
                        this.left.insert(n);
                    }
                }else{
                    //check right side for insert location
                    if(this.right == null){
                        console.log("Inserted " + n.value + " as a right child of " + this.value);
                        n.parent = this;
                        this.right = n;
                        //check for validity
                        this.validateTree();
                    }else{
                        this.right.insert(n);
                    }
                }
            }

            delete(v){
                //go until you are the node to delete
                if(this.value == v){
                    console.log("Found node to delete: " + this.value);
                    var validator;
                    if (this.left){
                        console.log("Searching left subtree for a repalcement");
                        //if the toDelete node has a left child replace it with the largest node in the left subtree
                        var largestLeft = this.left;
                        while(largestLeft.right != null){
                            largestLeft = largestLeft.right;
                        }
                        console.log("Found largest left node: " + largestLeft.value);
                        //when the largest node is found, replace THAT node with ITS direct left child (may be null)
                        if(largestLeft.value > largestLeft.parent.value)
                            largestLeft.parent.right = largestLeft.left;
                        else
                            largestLeft.parent.left = largestLeft.left;

                        if(largestLeft.left){
                            largestLeft.left.parent = largestLeft.parent;
                            validator = largestLeft.left;
                        }else{
                            validator = largestLeft.parent;
                        }
                        console.log("Replaced largest left node: ", largestLeft.parent);
                        //then place the largst left node in this existing node's place
                        largestLeft.parent = this.parent;
                        largestLeft.left = this.left;
                        largestLeft.right = this.right;
                        if(this.parent && this.value > this.parent.value){
                            //I am a right child
                            this.parent.right = largestLeft;
                        }else if(this.parent){
                            //I am a left child
                            this.parent.left = largestLeft;
                        }else{
                            root = largestLeft;
                        }//otherwise root is deleted and no parent need be changed
                        console.log("Moved the largest left node to its repalcement position: ", largestLeft, largestLeft.parent);
                        //validate from the replacement node's parent (validator runs at end of next else statement)
                    }else{
                        console.log("Using right child as a replacement")
                        //replace this node with its right child it with its right node (may be null)
                        if(this.parent && this.value > this.parent.value){
                            //I am a right child
                            this.parent.right = this.right;
                            if(this.right)
                                this.right.parent = this.parent;
                        }else if(this.parent){
                            //I am a left child
                            this.parent.left = this.right;
                            if(this.right)
                                this.right.parent = this.parent;
                        }else{
                            root = this.right;
                        }
                        //validate from this node up
                        if(this.right)
                            validator = this.right;
                        else if(this.parent)
                            validator = this.parent;
                        else
                            validator = null;
                    }

                    if(validator)
                        validator.validateTree();
                    
                }else if(v < this.value && this.left != null){
                    //look to the left
                    this.left.delete(v);
                }else if(v > this.value && this.right != null){
                    //look to the right
                    this.right.delete(v);
                }else{
                    console.log("No such node to delete: " + v);
                }

                
            }
            
            display(){
                var v1 = this.value;
                var v2 = "null";
                var v3 = "null";

                if(this.left != null)
                    v2 = this.left.value;
                if(this.right != null)
                    v3 = this.right.value;

                console.log(v1 + ":" + v2 + "," + v3);
                if(this.left != null)
                    this.left.display();
                if(this.right != null)
                    this.right.display();
            }
        }

        function fixViolation(k1, k2, k3){
            console.log(k1, k2, k3);
            //find the relationship between k1 and k2
            var firstIsRight = (k1.right === k2);
            var secondIsRight = (k2.right === k3);
            var temp, temp1, temp2;
            
            if(firstIsRight && secondIsRight){
                //Right right rotation
                console.log("RR rotation");
                
                temp = k2.left;
                k2.left = k1;
                k1.right = temp;
                if(temp)
                    temp.parent = k1;
                
                k2.parent = k1.parent;
                k1.parent = k2;

                if(root === k1){
                    root = k2;
                }else if(k2.parent.value < k2.value){
                    //k2 is the left child of its parent
                    k2.parent.right = k2;
                }else{
                    k2.parent.left = k2;
                }
                console.log(k1, k2);
            }else if(firstIsRight && !secondIsRight){
                //Right left rotation
                console.log("RL rotation");
                temp1 = k3.left;
                temp2 = k3.right;
                k3.left = k1;
                k3.right = k2;
                
                k3.parent = k1.parent
                k1.parent = k3;
                k2.parent = k3;

                k1.right = temp1;
                if(temp1)
                    temp1.parent = k1;
                
                k2.left = temp2;
                if(temp2)
                    temp2.parent = k2;

                if(root === k1){
                    root = k3;
                }else if(k3.parent.value < k3.value){
                    k3.parent.right = k3;
                }else{
                    k3.parent.left = k3;
                }
                    
            }else if(!firstIsRight && secondIsRight){
                //Left Right rotation
                console.log("LR rotation");
                temp1 = k3.left;
                temp2 = k3.right;
                k3.right = k1;
                k3.left = k2;

                k3.parent = k1.parent
                k1.parent = k3;
                k2.parent = k3;

                k2.right = temp1;
                if(temp1)
                    temp1.parent = k2;
                
                k1.left = temp2;
                if(temp2)
                    temp2.parent = k1;

                if(root === k1){
                    root = k3;
                }else if(k3.parent.value < k3.value){
                    k3.parent.right = k3;
                }else{
                    k3.parent.left = k3;
                }
            }else{
                //Left left rotation
                console.log("LL rotation");

                temp = k2.right;
                k2.right = k1;
                k1.left = temp;
                if(temp)
                    temp.parent = k1;

                k2.parent = k1.parent;
                k1.parent = k2;
                
                if(root === k1){
                    console.log("Changing root from " + k1.value + " to " + k2.value)
                    root = k2;
                }else if(k2.parent.value < k2.value){
                    k2.parent.right = k2;
                }else{
                    k2.parent.left = k2;
                }

            }
            console.log("Rotation Complete");
            root.display();
        }

    </script>
</body>
</html>
